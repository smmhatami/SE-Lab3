# گزارش آزمایش سوم درس مهندسی نرم افزار

## اعضای گروه

+ سید محمدمهدی حاتمی 98109561
+ پیمان حاجی محمد 98170776

## شرح آزمایش

### گام صفر : ساخت پروژه 

در ابتدای امر همچون آزمایش های قبلی محیط گیت را راه اندازی کرده و قوانین لازم روی برنچ اصلی آن را اعمال می کنیم. 

سپس ساختار و فولدر بندی پروژه را تشکیل میدهیم و با کمک افزونه ی مناسب، محیط تست را راه اندازی می کنیم. 

![Screenshot from 2023-11-10 21-53-01](https://github.com/smmhatami/SE-Lab3/assets/62210297/d4c248c1-22e1-4049-be7b-084a087f8706)

### گام یک : توسعه‌ی تست ها 
برای این قسمت به ترتیب تست هایی مرتبط با محاسبه ی مساحت، گرفتن و تغییر طول و عرض مستطیل توسعه می دهیم و در ادامه همین تست ها را برای مربع نیز توسعه می دهیم. 

در هر یک از متد های تست، ۵ نمونه را برای بررسی پیاده سازی می کنیم.

در این مرحله با توجه به خالی بودن بدنه ی برنامه، کامپایل ارور های زیادی در کد مشاهده می کنیم. 

### گام دو : شناسایی ارور های کد 
در اولین اجرای کد تست خطایی مبنی بر public نبودن متد های تست دریافت می کنیم و در نتیجه آن ها را public تعریف می کنیم. 
حال وقتی دوباره تست ها را اجرا می کنیم، لیست خطاهای آن قابل مشاهده است. 

![Screenshot from 2023-11-10 22-01-43](https://github.com/smmhatami/SE-Lab3/assets/62210297/aa1d169e-0c88-4512-a7cf-acf78cd533db)



## پرسش ها
1. در چرخه ی عمومی توسعه ی نرم افزار، تست ها پس از پیاده سازی کد و به هدف کسب اطمینان از صحت عملکرد برنامه پیاده سازی می شوند ولی در توسعه ی آزمون رانه، تست ها به عنوان نقشه ی راهی برای پیاده سازی کد در نظر گرفته می شوند. در نتیجه تفاوت این دو تست فقط در ترتیب نوشتن آن ها نیست و هدف و عملکرد آن ها نیز متفاوت است. برای مثال اگر یک سناریوی تست پیاده سازی نشود، در چرخه ی عمومی صرفا از عملکرد صحیح برنامه ی ما در ان سناریو اطمینانی حاصل نمیشود ولی در توسعه ی آزمون رانه، در عمل آن سناریو به کلی در نظر گرفته نخواهد شد چرا که انگار از اهداف توسعه ی ما خارج بوده است. به طور کلی این دو مدل توسعه تفاوت بنیادین با یکدیگر دارند و این تست ها شبیه به هم نیستند.
2. مفهوم granularity در تست های نرم افزار، به میزان گستردگی عملکرد هایی که یک تست پوشش می دهد اشاره می کند. یک تست میتواند بسیار ریزدانه باشد و تنها یک متد را تحت تست قرار دهد یا بزرگتر بوده و صفر تا صد سناریو های کاربر نرم افزار را از ابتدا تا انتها تحت پوشش قرار دهد. هرم زیر نمایش خوبی از این تقسیم بندی در اختیار ما قرار می دهد.

![image](https://github.com/smmhatami/SE-Lab3/assets/62210297/dbd7aa07-1688-41e8-a82b-e581e0970550)

در پایین ترین طبقه ی این هرم unit test ها را مشاهده می کنیم که همانطور که از نام آن ها بر می آید، تنها یک متد از سیستم را به صورت جداگانه و واحد تست می کنند. نوشتن این تست ها هزینه ی فنی پایینی دارد و از همین رو بیشترین حجم تست های یک نرم افزار را تشکیل می دهند. برای مثال در یک سایت خرید، در این مرحله فقط عملکرد تابع محاسبه ی مجموع قیمت سبد خرید را تست می کنیم. 

در لایه ی بعدی تست های یکپارچگی یا Integration تست ها را داریم که یک پله از تست های واحد بالاتر آمده و کنار هم قرار گرفتن چند عملکرد نرم افزار را تست می کنند. برای مثال در همان سایت خرید میتوانیم دیتابیس سیستم را هم راه اندازی کرده و محاسبه ی قیمت را با لود کردن از دیتابیس تست کنیم تا هماهنگ بودن این توابع نیز در کنار هم تست شود. 

در آخرین لایه و نوک هرم نیز تست های end to end را داریم که به گونه ای خود را جای کاربر گذاشته و صفر تا صد مسیر کاربر (user journey) را در نرم افزار تست می کنند. مثلا در سایت خرید اینجا رباتی توسعه می دهیم که وارد نرم افزار شده و یک سبد خرید ساخته و تا پایان خرید آن پیش می رود. این تست ها بسیار پر هزینه از لحاظ توسعه هستند و پیچیدگی زیادی دارند و عموما تعداد نسبتا کمی از آن ها در نرم افزار ما موجود است. 

