# گزارش آزمایش سوم درس مهندسی نرم افزار

## اعضای گروه

+ سید محمدمهدی حاتمی 98109561
+ پیمان حاجی محمد 98170776

## شرح آزمایش

### گام صفر : ساخت پروژه 

در ابتدای امر همچون آزمایش های قبلی محیط گیت را راه اندازی کرده و قوانین لازم روی برنچ اصلی آن را اعمال می کنیم. 

سپس ساختار و فولدر بندی پروژه را تشکیل میدهیم و با کمک افزونه ی مناسب، محیط تست را راه اندازی می کنیم. 

![Screenshot from 2023-11-10 21-53-01](https://github.com/smmhatami/SE-Lab3/assets/62210297/d4c248c1-22e1-4049-be7b-084a087f8706)

### گام یک : توسعه‌ی تست ها 
برای این قسمت به ترتیب تست هایی مرتبط با محاسبه ی مساحت، گرفتن و تغییر طول و عرض مستطیل توسعه می دهیم و در ادامه همین تست ها را برای مربع نیز توسعه می دهیم. 

در هر یک از متد های تست، ۵ نمونه را برای بررسی پیاده سازی می کنیم.

در این مرحله با توجه به خالی بودن بدنه ی برنامه، کامپایل ارور های زیادی در کد مشاهده می کنیم. 

### گام دو : شناسایی ارور های کد 
در اولین اجرای کد تست خطایی مبنی بر public نبودن متد های تست دریافت می کنیم و در نتیجه آن ها را public تعریف می کنیم. 
حال وقتی دوباره تست ها را اجرا می کنیم، لیست خطاهای آن قابل مشاهده است. 

![Screenshot from 2023-11-10 22-01-43](https://github.com/smmhatami/SE-Lab3/assets/62210297/aa1d169e-0c88-4512-a7cf-acf78cd533db)




### گام سه : پیاده سازی بدنه کد
هنگامی که کد بخش تست را مشاهده می کنیم با تعداد زیادی ارور زمان کامپایل مواجه می شویم.
![1_compileerror](https://github.com/smmhatami/SE-Lab3/assets/61017890/c4ff0cd7-c7b8-404b-b7a5-7d68fbb2ffc1)

در اقدام اول، کلاس های Rectangle و Square را ایجاد نموده و توابع مربوطه را برای آن با بنده خالی پیاده سازی می کنیم تا ارور های کامپایلی از بین بروند. سپس اقدام به پیاده سازی منطق این توابع می کنیم.

![2_rectClass](https://github.com/smmhatami/SE-Lab3/assets/61017890/2c2ae26a-ed88-4ca4-975d-1e8b9eac2435)

![3_squClass](https://github.com/smmhatami/SE-Lab3/assets/61017890/f4d0d469-ef64-4a97-9aae-21b41b1eae87)

حال نوبت به اجرای تست هایی که در ابتدا نوشته ایم می رسد:
![4_rectTest](https://github.com/smmhatami/SE-Lab3/assets/61017890/6d369115-dae8-4b11-8fef-7f364333817a)

![5_squTest](https://github.com/smmhatami/SE-Lab3/assets/61017890/ce2345bc-91d2-4e6e-9d43-11cec7c8bdc0)

همانطور که در تصاویر بالا نیز مشاهده می کنید تمامی تست های نوشته شده پاس شده اند و بدین ترتیب نیازمندی های در نظر گرفته شده برطرف شدند.






## پرسش ها
1. در چرخه ی عمومی توسعه ی نرم افزار، تست ها پس از پیاده سازی کد و به هدف کسب اطمینان از صحت عملکرد برنامه پیاده سازی می شوند ولی در توسعه ی آزمون رانه، تست ها به عنوان نقشه ی راهی برای پیاده سازی کد در نظر گرفته می شوند. در نتیجه تفاوت این دو تست فقط در ترتیب نوشتن آن ها نیست و هدف و عملکرد آن ها نیز متفاوت است. برای مثال اگر یک سناریوی تست پیاده سازی نشود، در چرخه ی عمومی صرفا از عملکرد صحیح برنامه ی ما در ان سناریو اطمینانی حاصل نمیشود ولی در توسعه ی آزمون رانه، در عمل آن سناریو به کلی در نظر گرفته نخواهد شد چرا که انگار از اهداف توسعه ی ما خارج بوده است. به طور کلی این دو مدل توسعه تفاوت بنیادین با یکدیگر دارند و این تست ها شبیه به هم نیستند.
2. مفهوم granularity در تست های نرم افزار، به میزان گستردگی عملکرد هایی که یک تست پوشش می دهد اشاره می کند. یک تست میتواند بسیار ریزدانه باشد و تنها یک متد را تحت تست قرار دهد یا بزرگتر بوده و صفر تا صد سناریو های کاربر نرم افزار را از ابتدا تا انتها تحت پوشش قرار دهد. هرم زیر نمایش خوبی از این تقسیم بندی در اختیار ما قرار می دهد.

![image](https://github.com/smmhatami/SE-Lab3/assets/62210297/dbd7aa07-1688-41e8-a82b-e581e0970550)

در پایین ترین طبقه ی این هرم unit test ها را مشاهده می کنیم که همانطور که از نام آن ها بر می آید، تنها یک متد از سیستم را به صورت جداگانه و واحد تست می کنند. نوشتن این تست ها هزینه ی فنی پایینی دارد و از همین رو بیشترین حجم تست های یک نرم افزار را تشکیل می دهند. برای مثال در یک سایت خرید، در این مرحله فقط عملکرد تابع محاسبه ی مجموع قیمت سبد خرید را تست می کنیم. 

در لایه ی بعدی تست های یکپارچگی یا Integration تست ها را داریم که یک پله از تست های واحد بالاتر آمده و کنار هم قرار گرفتن چند عملکرد نرم افزار را تست می کنند. برای مثال در همان سایت خرید میتوانیم دیتابیس سیستم را هم راه اندازی کرده و محاسبه ی قیمت را با لود کردن از دیتابیس تست کنیم تا هماهنگ بودن این توابع نیز در کنار هم تست شود. 

در آخرین لایه و نوک هرم نیز تست های end to end را داریم که به گونه ای خود را جای کاربر گذاشته و صفر تا صد مسیر کاربر (user journey) را در نرم افزار تست می کنند. مثلا در سایت خرید اینجا رباتی توسعه می دهیم که وارد نرم افزار شده و یک سبد خرید ساخته و تا پایان خرید آن پیش می رود. این تست ها بسیار پر هزینه از لحاظ توسعه هستند و پیچیدگی زیادی دارند و عموما تعداد نسبتا کمی از آن ها در نرم افزار ما موجود است. 

3. خیر تنها بخشی از این آزمون ها توسط برنامه نویسان بوجود می آید، برخی دیگر از انواع این تست ها توسط سایر افراد حاضر در تیم مانند مهندس تست بوجود آمده تا از درستی عملکرد کلی سیستم و برآورده شدن کامل نیاز های ذی نفع اطمینان حاصل شود.
4. اصول SOLID در تمام گام‌های اصلی ایجاد نرم‌افزار، از تحلیل نیازمندی‌ها تا استقرار، قابل استفاده هستند. در ادامه به توضیح نحوه استفاده از هر یک از این اصول در هر یک از این گام‌ها می‌پردازیم:

+ تحلیل نیازمندی‌ها

در تحلیل نیازمندی‌ها اصول SOLID می‌توانند به ما کمک کنند تا نیازمندی‌های نرم‌افزار را به طور دقیق و واضح مشخص کنیم. به عنوان مثال، اصل Single Responsibility Principle (SRP) به ما کمک می‌کند تا هر نیازمندی را به یک کلاس یا ماژول اختصاص دهیم تا مسئولیت آن واضح باشد.
+ طراحی

در گام طراحی، اصل Interface Segregation Principle (ISP) به ما کمک می‌کند تا رابط‌های کاربری را به گونه‌ای طراحی کنیم که تنها ویژگی‌های مورد نیاز هر کلاس یا ماژول را در بر بگیرند. همچنین، اصل Dependency Inversion Principle (DIP) به ما کمک می‌کند تا وابستگی‌ها را بین کلاس‌ها و ماژول‌ها به گونه‌ای طراحی کنیم که کلاس‌های بالادستی از کلاس‌های پاییندستی وابستگی نداشته باشند.

+ پیاده‌سازی

در گام پیاده‌سازی، اصل Liskov Substitution Principle (LSP) به ما کمک می‌کند تا کلاس‌های فرزند را به گونه‌ای پیاده‌سازی کنیم که بتوانند به جای کلاس‌های والد استفاده شوند.

+ آزمون

در این، اصل Single Responsibility Principle (SRP) به ما کمک می‌کند تا هر آزمون را به یک هدف مشخص اختصاص دهیم. همچنین، اصل Dependency Inversion Principle (DIP) به ما کمک می‌کند تا وابستگی‌های آزمون‌ها را به گونه‌ای طراحی کنیم که آزمون‌ها از جزئیات پیاده‌سازی مستقل باشند.

+ استقرار

در این گام اصل Single Responsibility Principle (SRP) به ما کمک می‌کند تا هر ماژول را به یک کار مشخص اختصاص دهیم.

5. بله امکان اینکار وجود دارد، پیاده سازی توابع get بدین صورت خواهد بود که برای طول و عرض مقدار یکسانی بر خواند گرداند. همچنین می توان تابع سازنده را برای مربع به گونه ای پیاده سازی کرد که تنها یک ورودی داشته باشد.
